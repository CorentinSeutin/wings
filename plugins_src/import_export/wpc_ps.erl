%%
%%  wpc_ps.erl --
%%
%%    Adobe PostScript (*.ps/*.eps) import based on wpc_ai.erl by Howard Trickey
%%    To work, the wpc_ai plugin must also be loaded.
%%
%%  Copyright (c) 2009-2011 Richard Jones.
%%                2017 Micheus (add/fixed support to Adobe Illustrator, LibreOffice, Inkscape and scribus (partial)).
%%                2023 Edward Blake (color support)
%%
%%  See the file "license.terms" for information on usage and redistribution
%%  of this file, and for a DISCLAIMER OF ALL WARRANTIES.
%%
%%     $Id$
%%

-module(wpc_ps).
-export([init/0,menu/2,command/2]).

-include_lib("wings/e3d/e3d.hrl").
-include_lib("wings/e3d/e3d_image.hrl").
-include_lib("wings/intl_tools/wings_intl.hrl").

-define(SCALEFAC, 0.01).		% amount to scale PS coords by

-record(cedge,% polyarea and cedge records must match definitions in wpc_ai.erl
        {vs,cp1=nil,cp2=nil,ve}).	%all are {x,y} pairs

-record(path,
        {ops=[],			%list of pathops
         close=false}).		%true or false

-record(pathop,
        {opkind,			%pmoveto, plineto, or pcurveto
         x1=0.0,
         y1=0.0,
         x2=0.0,
         y2=0.0,
         x3=0.0,
         y3=0.0}).

-record(pstate,
        {curpath=#path{},               %current path
         objects=[],                    %object list (paths)
         objects_coltex=[],
         curobjs=[],                    %current object been processed
         curobj_col=none,
         curobj_clip=[],
         ctm=[],
         ctms=[]                        % Stack of CTMs
         }).

-record(coltex,
        {fcol=none,
         scol=none,
         tex=none
        }).


init() -> true.

menu({file,import}, Menu) ->
    Menu ++ [{"Adobe PostScript (.ps|.eps)...", ps, [option]}];
menu(_, Menu) -> Menu.

command({file,{import,{ps,Ask}}}, _St) when is_atom(Ask) ->
    DefBisect = wpa:pref_get(wpc_ps, ps_bisections, 0),
    wpa:ask(Ask, ?__(4,"PS/EPS Import Options"),
            [{?__(2,"Number of edge bisections"), DefBisect}],
            fun(Res) -> {file,{import, ps, Res}} end);
command({file,{import, ps, [Nsub]}}, St) ->
    Props = [{extensions,[{".ps",?__(5,"PostScript File")},
                          {".eps",?__(6,"Encapsulated PostScript File")}]}],
    wpa:import(Props, fun(F) -> make_ps(F, Nsub) end, St);

command(_, _) ->
    next.


%% Built-in quirks table for different EPS creators
%%
default_quirks() ->
    [
        {{str,"ADOBE"},       "Adobe",             adobe,        {1.0, -1.0}, [adobe_cmds]},
        {{str,"LIBREOFFICE"}, "LibreOffice",       libre_office, {1.0, -1.0}, [libreoff_cmds]},
        {{str,"CAIRO"},       "InkScape",          inkscape,     {1.0, -1.0}, [fix_close,inkscape_cmds]},
        {{str,"SCRIBUS"},     "Scribus (partial)", scribus,      {1.0,  1.0}, [scribus_cmds]}
        
        %% Cairo is used by both inkscape and ipe, the eps output looks the same
    ].

%% Quirks details for the given EPS file being imported.
-record(quirksdetails, {
    direction = {1.0, -1.0} :: {float(), float()},
    fixes = []              :: [atom()]
}).

%% Pseudo-command generated by the importer to substitute embed image data.
-define(W3DEMBEDIMG, "w3dembedimg*").


make_ps(Filename, Nsubsteps) ->
    try try_import_ps(Filename, Nsubsteps) of
        {ok, E3dFile} ->
            wpa:pref_set(wpc_ps, ps_bisections, Nsubsteps),
            {ok, E3dFile};
        {error,Reason} ->
            {error, ?__(1,"PS import failed")++": " ++ Reason}
    catch EClass:E:ST ->
            io:format("File Import Error Report:\n ~p ~p\nstack trace: ~p\n",
                [EClass, E, ST]),
            {error, ?__(2,"PS import internal error")}
    end.

try_import_ps(Filename, Nsubsteps) ->
    QuirksTab = default_quirks(),
    case file:read_file(Filename) of
        {ok,<<"%!PS-Adobe",Rest0/binary>>} ->
            ShortFilename = filename:rootname(filename:basename(Filename)),
            
            %% Split the postscript from the image data early on so tokenize_bin_ps
            %% doesn't have to tokenize through the encoded images.
            {ImgList, Rest} = get_emb_images(Rest0),
            case tokenize_bin_ps(Rest, QuirksTab) of
                {{error,no_token}, Creator, _} ->
                    {error, Creator ++ "\n"++?__(2,"File doesn't have a valid token structure")};
                {{error,unsupported}, Creator, _} ->
                    {error, Creator ++ "\n"++?__(3,"File creator unsupported")};
                {Objs0, Creator, {QuirksDetails, ColTex}} ->
                    Objs = break_grouped_moveto(Objs0),
                    Closedpaths = [[P || P <- Obj, P#path.close == true, length(P#path.ops) > 2] || Obj <- Objs, Obj=/=[]],
                    case Closedpaths of
                        [] -> {error, Creator ++ "\n"++?__(4,"File mismatch or doesn't have valid paths")};
                        _ ->
                            Scale = ?SCALEFAC, %% We need to rescale both the UV and contours.
                            Colors = [fill_color(C) || #coltex{fcol=C}=_ <- ColTex],
                            TexList = [tex_atom(TexInfo, ShortFilename, ImgList, Scale)
                                         || #coltex{tex=TexInfo} <- ColTex],
                            Closedpaths0 = do_fixes(QuirksDetails, Closedpaths),
                            Cntrs0 = getcontours(QuirksDetails, Scale, Closedpaths0),
                            Cntrs = reverse_def(Cntrs0),
                            %% giving some information to the user about possible absent objects
                            if length(Cntrs) =/= length(Objs) ->
                                io:format("~ts: ~ts\n",
                                    [Creator,
                                     ?__(5,"Some token structures were not valid in the file and were ignored")]);
                                true -> ok
                            end,
                            MatList = materials_for_imglist(ShortFilename, ImgList),
                            Pas0 = [ wpc_ai:findpolyareas(Cntr) || Cntr <- Cntrs],
                            Pas1 = [ wpc_ai:subdivide_pas(Pa,Nsubsteps) || Pa <- Pas0],
                            Pas2 = lists:append(Pas1),
                            List = process_islands(Pas2),
                            {Vs0,Efs,Tx,HEs} = into_mesh_parts(List, TexList),
                            Center = e3d_vec:average(e3d_vec:bounding_box(Vs0)),
                            Vec = e3d_vec:sub(e3d_vec:zero(),Center),
                            Vs = lists:reverse(center_object(Vec,Vs0)),
                            Mesh = #e3d_mesh{type=polygon,vs=Vs,fs=Efs,tx=Tx,vc=Colors,he=HEs},
                            Obj = #e3d_object{name=ShortFilename,obj=Mesh,mat=MatList},
                            {ok, #e3d_file{objs=[Obj]}}
                    end
            end;
        {ok,_} ->
            {error,?__(1,"Not an Adobe PostScript file")};
        {error,Reason} ->
            {error,file:format_error(Reason)}
    end.

%%% put the object definition in reverse order to build taces with valid normals
reverse_def(Contours) ->
    [[lists:reverse(Cntr) || Cntr <- Cntrs] || Cntrs <- Contours, Cntrs=/=[[]]].

process_islands(Plas) ->
    Objs =
        lists:foldr(fun(Pla, Acc) ->
            %% it was noticed during the tests that some files may contain data that causes
            %% wpc_tt crashes with a key_exists error. We ignore that path definition and go on
            try process_islands_1(Pla) of
                {Vs,Fs,He}=Res when is_list(Vs), is_list(Fs), is_list(He) ->
                    [Res|Acc]
            catch error:{key_exists,_} ->
                Acc
            end
        end, [], Plas),
    Objs. % fix_slands_vertices(Objs).
process_islands_1(Pla) ->
    wpc_ai:polyareas_to_faces([Pla]).

%%% fixes the vertex number relative to the entire object to be created.

into_mesh_parts(Objs, TexList) ->
    into_mesh_parts(Objs, TexList, 0, 0, 0, [], [], [], []).
into_mesh_parts([], _, _, _, _, Vs_L, Fs_L, Tx_L, He_L) ->
    {lists:append(lists:reverse(Vs_L)),
     lists:append(lists:reverse(Fs_L)),
     lists:append(lists:reverse(Tx_L)),
     lists:append(lists:reverse(He_L))};
into_mesh_parts([{Vs,Fs0,He0} | Objs], [Tex | TexList], ColorIdx,
                VsOffset, TxOffset, Vs_L, Fs_L, Tx_L, He_L) ->
    case Tex of
        none ->
            Tx = [],
            TxOffset_1 = TxOffset;
        {BitmapCTM, _} ->
            Tx = [to_uv(BitmapCTM, X, Y) || {X,Y,_} <- Vs],
            TxOffset_1 = TxOffset + length(Vs)
    end,
    VsOffset_1 = VsOffset + length(Vs),
    EFs = [ #e3d_face{
        vs=[V+VsOffset || V <- F],
        vc=[ColorIdx   || _ <- F],
        tx=[V+TxOffset || V <- F],
        mat=
            case Tex of
                none -> [];
                {_, M} -> [M]
            end
    } || F <- Fs0],
    He = [{V1+VsOffset,V2+VsOffset} || {V1,V2} <- He0],
    
    Vs_1 = Vs,
    
    into_mesh_parts(Objs, TexList, ColorIdx + 1, VsOffset_1, TxOffset_1,
                    [Vs_1 | Vs_L], [EFs | Fs_L], [Tx | Tx_L], [He | He_L]).

to_uv({ScaleX, _, _, ScaleY0, TrX, TrY0}, X, Y) ->
    ScaleY = -ScaleY0,
    TrY = -TrY0,
    UV = {(X-TrX) * ScaleX, (Y-TrY) * ScaleY},
    UV.

fill_color(none) ->
    {0.4, 0.4, 0.4};
fill_color({_R,_G,_B}=Col) ->
    Col.

new_tex_atom(ShortFilename, TexNumber) ->
    list_to_atom(ShortFilename ++ "_" ++ integer_to_list(TexNumber)).

tex_atom({CTM, TexNumber}, ShortFilename, ImgList, Scale)
  when is_list(ImgList), length(ImgList) > TexNumber ->
    case lists:nth(TexNumber + 1, ImgList) of
        unused ->
            none;
        {A, _} when A =:= jpeg ->
            AtomName = new_tex_atom(ShortFilename, TexNumber),
            {rescale_image_ctm(CTM, Scale), AtomName}
    end;
tex_atom(_, _, _, _) ->
    none.

%% Rescale image texture placement
rescale_image_ctm({M1,M2,M3,M4,M5,M6}, Scale) ->
    {M1*Scale,M2,M3,M4*Scale,M5*Scale,M6*Scale}.

%% Textures list for e3d_file
materials_for_imglist(ShortFilename, ImgList) when is_list(ShortFilename) ->
    materials_for_imglist(ShortFilename, ImgList, 0, []).
materials_for_imglist(_ShortFilename, [], _I, OMat) ->
    lists:reverse(OMat);
materials_for_imglist(ShortFilename, [unused|R], I, OMat) ->
    materials_for_imglist(ShortFilename, R, I + 1, OMat);
materials_for_imglist(ShortFilename, [{_, _}=ImgData|R], I, OMat) ->
    case get_bitmap(ImgData) of
        {ok, #e3d_image{}=E3dImage} ->
            AtomName = new_tex_atom(ShortFilename, I),
            Maps = {maps, [{diffuse, E3dImage}]},
            OpenGL = {opengl,
                     [{ambient,{0.0,0.0,0.0,0.0}},
                      {specular, {0.2,0.2,0.2,1.0}},
                      {shininess,0.2},
                      {diffuse, {0.8,0.8,0.7,1.0}},
                      {emission,{0.0,0.0,0.0,1.0}},
                      {metallic,0.1},
                      {roughness,0.8},
                      {vertex_colors, set}]},
            M = {AtomName, [Maps, OpenGL]},
            materials_for_imglist(ShortFilename, R, I + 1, [M | OMat])
    end.


%% some paths definitions can contain many 'pmoveto' operators that cannot be understand
%% for the code in wpc_ai module. Then, we break them in separated objects in order to
%% provide user with most objects as he/she expect to get.
break_grouped_moveto(Objs) ->
    [break_grouped_moveto_0(Paths,[]) || Paths <- Objs].
break_grouped_moveto_0([], Acc) -> lists:flatten(Acc);
break_grouped_moveto_0([#path{ops=Ops0}=Path0|Paths], Acc0) ->
    Acc =
        case break_grouped_moveto_1(lists:reverse(Ops0),[],[]) of
            [Ops0] -> Path0;
            NewOps -> [#path{ops=NOps,close=true} || NOps <- NewOps]
        end,
    break_grouped_moveto_0(Paths, [Acc|Acc0]).
break_grouped_moveto_1([], [], Acc) -> Acc;
break_grouped_moveto_1([], Ops0, Acc) -> [Ops0|Acc];
break_grouped_moveto_1([#pathop{opkind=pmoveto}=Path|Paths], Ops0, Acc) ->
    Ops = [Path|Ops0],
    break_grouped_moveto_1(Paths, [], [Ops|Acc]);
break_grouped_moveto_1([Path|Paths], Ops0, Acc) ->
    break_grouped_moveto_1(Paths, [Path|Ops0], Acc).


center_object(Vec,Vs) ->
    lists:foldl(fun(V,Acc) ->
        {X,Y,Z} = e3d_vec:add(V,Vec),
        [{X,Y,Z}|Acc]
    end,[],Vs).

tokenize_bin_ps(Bin, QuirksTab) ->
    CommandMap0 = parse_prolog_ps(Bin),
    {Creator, Chars} = after_end_setup_ps(Bin, "Undefined"),
    case get_creator(Creator, QuirksTab) of
        {ok, ID, QuirksDetails} ->
            CommandMap = add_commands(CommandMap0, QuirksDetails),
            Toks = tokenize(Chars, []), % seems to be the same as what is needed for .ps
            case Toks of
                [] ->
                    Objs = {error,no_token},
                    ColTex = [];
                _ ->
                    put({?MODULE,eps_creator}, ID),
                    case parse_tokens_ps(Toks, CommandMap) of
                        {[], _} ->
                            Objs = {error,no_token},
                            ColTex = [];
                        {Objs0, ColTex0} ->
                            set_var(eps_scale,{1.0,1.0}),
                            set_var(eps_translate,{0.0,0.0}),
                            %% remove duplicated items since some files may
                            %% contain the fill and strock data for the same path definition
                            {Objs, ColTex} = merge_duplicates(Objs0, ColTex0)
                    end
            end;
        false ->
            QuirksDetails = none,
            Objs = {error,unsupported},
            ColTex = []
    end,
    {Objs, Creator, {QuirksDetails, ColTex}}.

add_commands(CommandMap, #quirksdetails{fixes=Fixes}=_QuirksDetails) ->
    add_commands_1(CommandMap, Fixes).
add_commands_1(CommandMap0, [inkscape_cmds|Fixes]) ->
    CommandMap = add_commands_if_absent(CommandMap0#{
        %% 're' means rectangle for Inkscape file. we translate it to regular operations and close the path
        "re" => {f4, fun({X1,Y1,W1,H1},Pst) ->
            Pst0 = finishpop(#pathop{opkind=pmoveto,x1=X1,y1=Y1},Pst),
            Pst1 = finishpop(#pathop{opkind=plineto,x1=X1,y1=Y1+H1}, Pst0),
            Pst2 = finishpop(#pathop{opkind=plineto,x1=X1+W1,y1=Y1+H1}, Pst1),
            Pst3 = finishpop(#pathop{opkind=plineto,x1=X1+W1,y1=Y1}, Pst2),
            finishrop(true,Pst3)
        end},
        "cm" => {f6, fun({M1,M2,M3,M4,M5,M6}, Pst) ->
            finishpop(#pathop{opkind=concat,x1=M1,y1=M2,x2=M3,y2=M4,x3=M5,y3=M6},Pst)
        end}
    }, [
        %% These will be added if they weren't already by bind def
        {"q", "gsave"},
        {"Q", "grestore"},
        {"m", "moveto"},
        {"l", "lineto"},
        {"c", "curveto"},
        {"h", "closepath"},
        {"S", "stroke"},
        {"f", "fill"},
        {"f*", "eofill"},
        {"n", "newpath"},
        {"W", "clip"},
        {"W*", "eoclip"}
    ]),
    add_commands_1(CommandMap, Fixes);
add_commands_1(CommandMap0, [libreoff_cmds|Fixes]) ->
    CommandMap = add_commands_if_absent(CommandMap0#{
        "ct" => {f6, fun({X1,Y1,X2,Y2,X3,Y3},Pst) ->
            finishpop(#pathop{opkind=pcurveto,x1=X1,y1=-Y1,x2=X2,y2=-Y2,x3=X3,y3=-Y3},Pst)
        end},
        "pc" => "closepath"
    }, [
        %% These will be added if they weren't already by bind def
        {"l", {neg, "lineto"}},
        {"rl", {neg, "rlineto"}},
        {"m", {neg, "moveto"}},
        {"r", "rotate"},
        {"t", {neg, "translate"}},
        {"s", "scale"},
        {"gs", "gsave"},
        {"gr", "grestore"},
        {"p", "closepath"},
        {"ef", "eofill"},
        {"ps", "stroke"}
    ]),
    add_commands_1(CommandMap, Fixes);
add_commands_1(CommandMap0, [adobe_cmds|Fixes]) ->
    CommandMap = add_commands_if_absent(CommandMap0, [
        {"cv", "curveto"},
        {"li", "lineto"},
        {"ct", "concat"},
        {"np", "newpath"},
        {"mo", "moveto"},
        {"cp", "closepath"},
        {"clp_npth", "clip"}, %% Actually clip newpath
        {"clp", "clip"},
        {"cmyk", "setcmykcolor"},
        {"rgb", "setrgbcolor"},
        {"gry", "setgray"},
        {"f", "fill"},
        {"ef", "eofill"},
        {"@", "stroke"},
        {"nclp", "clip"},
        {"ct", "concat"}
    ]),
    add_commands_1(CommandMap, Fixes);
add_commands_1(CommandMap0, [scribus_cmds|Fixes]) ->
    CommandMap = add_commands_if_absent(CommandMap0, [
        %% These will be added if they weren't already by bind def
        {"cmyk", "setcmykcolor"},
        {"m", "moveto"},
        {"l", "lineto"},
        {"li", "lineto"},
        {"cu", "curveto"},
        {"cl", "closepath"},
        {"gs", "gsave"},
        {"gr", "grestore"},
        {"tr", "translate"},
        {"ro", "rotate"},
        {"sc", "scale"},
        {"fi", "fill"},
        {"st", "stroke"}
    ]),
    add_commands_1(CommandMap, Fixes);
    
    
add_commands_1(CommandMap, [_|Fixes]) ->
    add_commands_1(CommandMap, Fixes);
add_commands_1(CommandMap, []) ->
    CommandMap.

%% Add command mappings but only if they were not already defined.
%% 
add_commands_if_absent(CommandMap0, List) ->
    maps:merge(maps:from_list(List),CommandMap0).


%% Parse the prolog part of the file
parse_prolog_ps(Bin) ->
    [Bin1 | _] = string:split(Bin, <<"%%Page: ">>),
    Chars = binary_to_list(Bin1),
    Toks = tokenize(Chars, []),
    CommandMap = parse_pl(Toks, unassigned, maps:new()),
    CommandMap.

%% Map bind definitions into a CommandMap
parse_pl([],_BDef,CommandMap) -> % done
    CommandMap;
parse_pl([{tlitname,ShortName},{tname,"{"},{tname,CallName},{tname,"}"},{tname,"bind"},{tname,"def"}|T], BDef, CommandMap) ->
    parse_pl(T,BDef,CommandMap#{ShortName => CallName});
parse_pl([{tlitname,ShortName},{tname,"{"},{tname,CallName},{tname,"}"},{tname,BDef}|T], BDef, CommandMap) ->
    parse_pl(T,BDef,CommandMap#{ShortName => CallName});
parse_pl([{tlitname,ShortName},{tname,"{"},{tname,"neg"},{tname,CallName},{tname,"}"},{tname,BDef}|T], BDef, CommandMap) ->
    parse_pl(T,BDef,CommandMap#{ShortName => {neg, CallName}});

%% For files that shorten bind def (e.g. libreoffice)
parse_pl([{tlitname,ShortName},{tname,"{"},{tname,"bind"},{tname,"def"},{tname,"}"},{tname,"bind"},{tname,"def"}|T], _, CommandMap) ->
    parse_pl(T,ShortName,CommandMap);

parse_pl([_|T], BDef, CommandMap) ->
    parse_pl(T, BDef, CommandMap).


%% Get the creator from the quirks table
%%
get_creator(Creator0, QuirksTab) ->
    Creator = string:to_upper(Creator0),
    io:format("~w: EPS Creator: ~p\n",[?MODULE, Creator]),
    get_creator_1(Creator, QuirksTab).
get_creator_1(Creator, [{{str, StrComp},_Comment,ID,CDir,Fixes}|QuirksTab]) ->
    Idx = string:str(Creator, StrComp),
    if Idx > 0 ->
            {ok, ID, #quirksdetails{direction=CDir,fixes=Fixes}};
        true ->
            get_creator_1(Creator, QuirksTab)
    end;
get_creator_1(_Creator, []) ->
    false.



%% used to ensure the value is stored once - no overwrite if any other
%% scale and translate tags are found
set_var(Var, Value) when is_atom(Var) ->
    case get(Var) of
        undefined -> put({?MODULE,Var}, Value);
        _ -> ignore
    end.

%% skip until after %%Page: 1 1 line, as we currently use nothing before that,
%% then convert rest of binary to list of characters
after_end_setup_ps(<<"%%Page: 1 1",Rest1/binary>>, Creator) ->
    Rest0 = re:replace(Rest1, " \\.", " 0\\.", [global,{return,list}]),
    Rest = re:replace(Rest0, "\n\\.", "\n0\\.", [global,{return,list}]),
    {Creator, Rest};
after_end_setup_ps(<<"%%Creator:",Rest/binary>>, _) ->
    <<Line1:255/binary,_/binary>> = Rest,
    Line0 = binary_to_list(Line1),
    Idx = string:str(Line0, "%"),
    Line = string:sub_string(Line0, 1, Idx-1),
    Creator = string:strip(string:strip(string:strip(Line, right, $\n), right, $\r), both),
    after_end_setup_ps(Rest, string:to_upper(Creator));
after_end_setup_ps(<<_,Rest/binary>>, Creator) ->
    after_end_setup_ps(Rest, Creator);
after_end_setup_ps(_, Creator) -> {Creator, []}.

%% tokenize first list (characters from file) into list of tokens
%% (accumulated reversed in second list, reversed at end).
%% a token is {tnum,Val}, {tname,Val}, {tlitname, Val}, or {tstring}

tokenize([], Toks) ->
    lists:reverse(Toks);
tokenize([C|T], Toks) when C == $\s; C == $\t; C == $\r; C == $\n;
            C == $); C == $> ->    % these 2 are "shouldn't happens"
    tokenize(T, Toks);
tokenize("%" ++ T, Toks) ->
    tokenize(skipline(T), Toks);
tokenize("/" ++ T, Toks) ->
    {Name,TT} = lists:splitwith(fun isnttokbreak/1, T),
    tokenize(TT, [{tlitname,Name}|Toks]);
tokenize("(" ++ T, Toks) ->
    tokenize(skipstring(T), [{tstring}|Toks]);
tokenize("<" ++ T, Toks) ->
    tokenize(skiphexstring(T), [{tstring}|Toks]);
tokenize([C|T], Toks) when C == $[; C == $]; C == ${; C == $} ->
    tokenize(T, [{tname,[C]}|Toks]);
tokenize([C|_] = Arg, Toks) when C >= $0, C =< $9; C==$-; C==$. ->
    {Tok,TT} = parsenum(Arg),
    tokenize(TT, [Tok|Toks]);
tokenize(Arg, Toks) ->
    {Name,TT} = lists:splitwith(fun isnttokbreak/1, Arg),
    tokenize(TT, [{tname,Name}|Toks]).

%% note: this list of chars be exactly those matched explicitly
%% by the non-default cases of tokenize, else get infinite loop
isnttokbreak(C) -> not(lists:member(C, " \t\r\n()<>[]{}/%")).

%% PS numbers are either ints or floats
%% no radix notation for ints, no scientific notation for floats
parsenum([C|Rest]=L) ->
    case re:run(L, "^((\\+|\\-?)([0-9]+\\.[0-9]*)|(\\.[0-9]+))",[{capture,first}]) of
        {match,[{0,Length}]} ->
            Fstr0 = lists:sublist(L, Length),
            Fstr =
            case Fstr0 of
                [$.|_] -> [$0|Fstr0];
                _ -> Fstr0
            end,
            F = list_to_float(Fstr),
            {{tnum,F}, lists:nthtail(Length, L)};
        nomatch ->
            case re:run(L, "^(\\+|-)?[0-9]+", [{capture,first}]) of
                {match, [{0, Length}]} ->
                    Istr = lists:sublist(L, Length),
                    I = list_to_integer(Istr),
                    {{tnum,float(I)}, lists:nthtail(Length, L)};
                nomatch ->
                    {{tname,[C]}, Rest}
            end
    end.

%% skip past next end of line, return rest
skipline("\r\n" ++ T) -> T;
skipline("\r" ++ T) -> T;   % sometimes find files with only CRs!
skipline("\n" ++ T) -> T;
skipline([_|T]) -> skipline(T);
skipline([]) -> [].

%% skip past next ")", but be careful about escaped ones
%% return rest
skipstring([]) -> [];
skipstring("\\") -> [];
skipstring("\\" ++ [_|T]) -> skipstring(T);
skipstring(")" ++ T) -> T;
skipstring([_|T]) -> skipstring(T).

%% skip past next ">", return rest
skiphexstring([]) -> [];
skiphexstring(">" ++ L) -> L;
skiphexstring([_|L]) -> skiphexstring(L).

%% consume tokens, return list of objects.
%% an object is either a path or a compoundpath.
parse_tokens_ps(Toks, CommandMap) ->
    #pstate{objects=Objs,objects_coltex=ColTex,curobjs=[]} = parse_ps(Toks, CommandMap, #pstate{}),
    {Objs, ColTex}.


%% PS Parse
parse_ps([],_CM,#pstate{objects=Objs0,objects_coltex=ColTex0,curobjs=[]}=Pst) -> % done
    Objs = lists:reverse(Objs0),
    ColTex = lists:reverse(ColTex0),
    Pst#pstate{objects=Objs,objects_coltex=ColTex};
parse_ps([],CM,#pstate{objects=Objs0,objects_coltex=ColTex0,curobjs=CObj,curobj_col=Col}=Pst) ->
    ColTex = [#coltex{fcol=Col,tex=none}|ColTex0],
    Objs = [CObj|Objs0],
    parse_ps([],CM,Pst#pstate{objects=Objs,objects_coltex=ColTex,curobjs=[],curobj_col=none,curobj_clip=[]});

parse_ps([{tname,"["},{tnum,X1},{tnum,Y1},{tnum,X2},{tnum,Y2},{tnum,X3},{tnum,Y3},
          {tname,"]"},{tname,[_|_]=N}|T], CM, Pst) ->
    parse_ps(T,CM,ps_dopathopmtx(N,{X1,Y1,X2,Y2,X3,Y3},CM,Pst));
parse_ps([{tname,[_|_]=N} | T ], CM, Pst) ->
    parse_ps(T,CM,ps_dorenderop(N,CM,ps_dopathop0(N,CM,Pst)));
parse_ps([{tnum,X1},{tname,[_|_]=N}|T], CM, Pst) ->
    parse_ps(T,CM,ps_dopathop1(N,{X1},CM,Pst));
parse_ps([{tnum,X1},{tnum,Y1},{tname,[_|_]=N}|T], CM, Pst) ->
    parse_ps(T,CM,ps_dopathop2(N,{X1,Y1},CM,Pst));
parse_ps([{tnum,X1},{tnum,X2},{tnum,X3},{tname,[_|_]=N}|T], CM, Pst) ->
    parse_ps(T,CM,ps_dopathop3(N,{X1,X2,X3},CM,Pst));
parse_ps([{tnum,X1},{tnum,Y1},{tnum,W1},{tnum,H1},{tname,[_|_]=N}|T], CM, Pst) ->
    parse_ps(T,CM,ps_dopathop4(N,{X1,Y1,W1,H1},CM,Pst));
parse_ps([{tnum,X1},{tnum,Y1},{tnum,X2},{tnum,Y2},{tnum,X3},{tnum,Y3},
        {tname,[_|_]=N}|T], CM, Pst) ->
    parse_ps(T,CM,ps_dopathop6(N,{X1,Y1,X2,Y2,X3,Y3},CM,Pst));
parse_ps([_|T], CM, Pst) ->
    parse_ps(T, CM, Pst).

negate_last({X,Y}) ->
    {X,-Y};
negate_last(A) ->
    A.

call_next(CP,CM,Val,Pst,FAtm,F) ->
    case maps:get(CP, CM, false) of
        false ->
            Pst;
        {FAtm, NextFun} when is_function(NextFun) ->
            NextFun(Val, Pst);
        {_, NextFun} when is_function(NextFun) ->
            Pst;
        {neg, NextCall} when is_list(NextCall) ->
            F(NextCall, negate_last(Val));
        NextCall when is_list(NextCall) ->
            F(NextCall, Val)
    end.


%% check if C is a no-arg path operation, and if so, return a modified Pst,
%% otherwise return original Pst
ps_dopathop0(CP,_CM,#pstate{curpath=P}=Pst)
  when CP=:="closepath" ->
    Pst#pstate{curpath=P#path{close=true}};
ps_dopathop0(CP,_CM,#pstate{ctm=CTM,ctms=CTMS0}=Pst)
  when CP=:="gsave" ->
    Pst#pstate{ctms=[CTM|CTMS0]};
ps_dopathop0(CP,_CM,#pstate{ctms=[CTM|CTMS0]}=Pst)
  when CP=:="grestore" ->
    Pst#pstate{ctm=CTM,ctms=CTMS0};
%% we use the clip path to get clipping shapes if they aren't bounding boxes.
ps_dopathop0(CP,_CM,#pstate{curpath=P,curobjs=CObjs0,curobj_clip=Clip0}=Pst)
  when CP=:="clip" ->
    CObjs = add_path(CObjs0, P),
    Pst#pstate{curobjs=[],curpath=#path{},curobj_clip=[CObjs|Clip0]};
ps_dopathop0(CP,CM,Pst) ->
    call_next(CP,CM,none,Pst,f0, fun (NextCall, _) ->
        ps_dopathop0(NextCall,CM,Pst)
    end).

ps_dopathop1(MT,{Val}, _, Pst) when MT=:="setgray" ->
    Pst#pstate{curobj_col={Val,Val,Val}};
ps_dopathop1(MT,Val, CM, Pst) ->
    call_next(MT,CM,Val,Pst,f1, fun (NextCall, Val1) ->
        ps_dopathop1(NextCall,Val1,CM,Pst)
    end).

ps_dopathop2(MT,{X1,Y1}, _, Pst) when MT=:="moveto" ->
    finishpop(#pathop{opkind=pmoveto,x1=X1,y1=Y1},Pst);
ps_dopathop2(LT,{X1,Y1}, _, Pst) when LT=:="lineto" ->
    finishpop(#pathop{opkind=plineto,x1=X1,y1=Y1},Pst);
ps_dopathop2(MT,{X1,Y1}, _, Pst) when MT=:="scale" ->
    finishpop(#pathop{opkind=scale,x1=X1,y1=Y1},Pst);
ps_dopathop2(MT,{X1,Y1}, _, Pst) when MT=:="translate" ->
    finishpop(#pathop{opkind=translate,x1=X1,y1=Y1},Pst);
ps_dopathop2(MT,{_,Idx0}, _, #pstate{curobjs=[],curobj_clip=Clip0,ctm=[CTM0|_]}=Pst)
  when MT=:=?W3DEMBEDIMG ->
    #pathop{x1=M1,y1=M2,x2=M3,y2=M4,x3=M5,y3=M6}=CTM0,
    TexIdx = round(Idx0),
    case lists:partition(fun is_path_rectangle/1, Clip0) of
        {[Clip|_], []} -> Clip;
        {_, Clip1} -> Clip = lists:append(Clip1)
    end,
    TexInfo = {{M1,M2,M3,M4,M5,M6}, TexIdx},
    finishrop(obj,Pst#pstate{curpath=#pathop{},curobjs=Clip,curobj_clip=[]},fill,TexInfo);
ps_dopathop2(MT,Val, CM, Pst) ->
    call_next(MT,CM,Val,Pst,f2, fun (NextCall, Val1) ->
        ps_dopathop2(NextCall,Val1,CM,Pst)
    end).

%% Fill color
ps_dopathop3(RT,{R,G,B},_CM,Pst) when RT=:="setrgbcolor" ->
    Pst#pstate{curobj_col={R,G,B}};
ps_dopathop3(RT,Val,CM,Pst) ->
    call_next(RT,CM,Val,Pst,f3, fun(NextCall, Val1) ->
        ps_dopathop3(NextCall,Val1,CM,Pst)
    end).

%% Commands like 're' for inkscape will be called here
ps_dopathop4(RT,{C,M,Y,K},_CM,Pst) when RT=:="setcmykcolor" ->
    R = (1.0 - C) * (1.0 - K),
    G = (1.0 - M) * (1.0 - K),
    B = (1.0 - Y) * (1.0 - K),
    Pst#pstate{curobj_col={R,G,B}};
ps_dopathop4(RT,Val,CM,Pst) ->
    call_next(RT,CM,Val,Pst,f4, fun(NextCall, Val1) ->
        ps_dopathop4(NextCall,Val1,CM,Pst)
    end).

ps_dopathop6(CT,{X1,Y1,X2,Y2,X3,Y3},_,Pst) when CT=:="curveto" ->
    finishpop(#pathop{opkind=pcurveto,x1=X1,y1=Y1,x2=X2,y2=Y2,x3=X3,y3=Y3},Pst);
ps_dopathop6(CT,Val,CM,Pst) ->
    call_next(CT,CM,Val,Pst,f6, fun(NextCall, Val1) ->
        ps_dopathop6(NextCall,Val1,CM,Pst)
    end).

ps_dopathopmtx(CT,{X1,Y1,X2,Y2,X3,Y3},_,Pst) when CT=:="concat" ->
    finishpop(#pathop{opkind=concat,x1=X1,y1=Y1,x2=X2,y2=Y2,x3=X3,y3=Y3},Pst);
ps_dopathopmtx(CT,Val,CM,Pst) ->
    call_next(CT,CM,Val,Pst,fm, fun(NextCall, Val1) ->
        ps_dopathopmtx(NextCall,Val1,CM,Pst)
    end).

%% finish job of dopathop[2,6] by putting arg pathop onto curpath's ops list
%% and returning Pst with modified curpath
finishpop(#pathop{opkind=pmoveto}=Pop, #pstate{curpath=#path{ops=[]}}=Pst) ->
    Pst#pstate{curpath=#path{ops=[Pop]}};
finishpop(#pathop{opkind=pmoveto}=Pop, #pstate{curpath=#path{ops=[#pathop{opkind=pmoveto}]}=P}=Pst) ->
    %% note: only one pmoveto is accept by path, so ignore a second one found in Inkscape's files
    Pst#pstate{curpath=P#path{ops=[Pop]}};
finishpop(#pathop{opkind=scale,x1=XS,y1=YS}, Pst) ->
    set_var(eps_scale,{XS,YS}),
    Pst;
finishpop(#pathop{opkind=translate,x1=XT,y1=YT}, Pst) ->
    set_var(eps_translate,{XT,YT}),
    Pst;
finishpop(#pathop{opkind=concat}=Pop, #pstate{ctm=CTM0}=Pst) ->
    Pst#pstate{ctm=[Pop|CTM0]};
finishpop(_, #pstate{curpath=#path{ops=[]}}=Pst) ->
    Pst;    % note: only pmoveto's can start path, so ignore others
finishpop(Pop, #pstate{curpath=#path{ops=Ops}=P}=Pst) ->
    Pst#pstate{curpath=P#path{ops=[Pop|Ops]}}.

ps_dorenderop(CP,_,Pst) when CP=:="closepath" ->
    finishrop(true,Pst);
ps_dorenderop(NP,_,Pst) when NP=:="newpath" ->
    finishrop(false,Pst);
ps_dorenderop(NP,_,Pst) when NP=:="fill"; NP=:="eofill" ->
    finishrop(obj,Pst,fill);
ps_dorenderop(NP,_,Pst) when NP=:="stroke" ->  % Stroke - sing a new object
    finishrop(obj,Pst,stroke);
ps_dorenderop(CP,CM,Pst) ->
    call_next(CP,CM,none,Pst,fr, fun (NextCall, _) ->
        ps_dorenderop(NextCall,CM,Pst)
    end).

%% If Nam is a renderop, finish off curpath and put on objects list.
finishrop(Close, Pst) ->
    finishrop(Close, Pst, none).
finishrop(Close, Pst, DrawOp) ->
    Tex = none,
    finishrop(Close, Pst, DrawOp, Tex).
finishrop(obj,#pstate{objects=Objs0,objects_coltex=ColTex0,curobjs=CObjs,curobj_col=Col}=Pst,DrawOp,Tex)
  when CObjs =/= [] ->
    case DrawOp of
        fill ->
            %% Change the color depending on if there is a texture
            Col1 = case Tex of none -> Col; _ -> {1.0,1.0,1.0} end,
            ColTex = [#coltex{fcol=Col1,tex=Tex}|ColTex0];
        _ ->
            ColTex = [#coltex{scol=Col,tex=Tex}|ColTex0]
    end,
    Objs = [CObjs|Objs0],
    Pst#pstate{objects=Objs,objects_coltex=ColTex,curobjs=[],curobj_col=none,curobj_clip=[]};
finishrop(obj,#pstate{curobjs=CObjs}=Pst,_DrOp,_Tex)
  when CObjs =:= [] ->
    Pst#pstate{curobj_col=none,curobj_clip=[]};
finishrop(Close,#pstate{curpath=#path{close=Pclose,ops=Ops}=P,curobjs=Objs}=Pst,_DrawOp,_Tex)
  when Ops =/= [] ->
    Newp = P#path{close=Close or Pclose,ops=lists:reverse(Ops)},
    Pst#pstate{curobjs=[Newp|Objs],curpath=#path{}};
finishrop(_Close,#pstate{curpath=#path{ops=Ops}=_}=Pst,_DrawOp,_Tex)
  when Ops =:= [] ->
    Pst.


add_path(Objs,#path{ops=[#pathop{opkind=pmoveto}]}=_) ->
    Objs;
add_path(Objs,#path{ops=Ops}=P)
  when Ops =/= [] ->
    Newp = P#path{ops=lists:reverse(Ops)},
    [Newp|Objs];
add_path(Objs,#path{ops=Ops}=_)
  when Ops =:= [] ->
    Objs.


%% Do fixes based on quirks details
%%
do_fixes(#quirksdetails{fixes=Fixes}, Objs) ->
    do_fixes_1(Fixes, Objs).
do_fixes_1([fix_close|FixProps], Objs) ->
    Objs_1 = [[fix_inkscape(Path) || Path <- Paths] || Paths <- Objs],
    do_fixes_1(FixProps, Objs_1);
do_fixes_1([_|FixProps], Objs) ->
    do_fixes_1(FixProps, Objs);
do_fixes_1([], Objs) ->
    Objs.


%%% fixes the inkscape issue that doesn't close the mesh in some situations
%%% in these cases we force a plineto command to the first pmoveto coordinate
fix_inkscape(#path{ops=[#pathop{opkind=pmoveto,x1=X,y1=Y}|Ops0]=Ops}=Path) ->
    [LastOp|_] = lists:reverse(Ops0),
    case LastOp of
        #pathop{opkind=plineto,x1=X,y1=Y} -> Path;
        #pathop{opkind=plineto} -> Path#path{ops=Ops++[#pathop{opkind=plineto,x1=X,y1=Y}]};
        #pathop{opkind=pcurveto,x3=X,y3=Y} -> Path;
        #pathop{opkind=pcurveto} -> Path#path{ops=Ops++[#pathop{opkind=plineto,x1=X,y1=Y}]};
        _ -> Path
    end.


getcontours(#quirksdetails{direction={XDir,YDir}}, Scale, Ps) ->
    {XS,YS} = get({?MODULE,eps_scale}),
    S = {XS*Scale*XDir,YS*Scale*YDir},
    T = get({?MODULE,eps_translate}),
    Ps0 = [lists:map(fun getcedges/1, P) || P <- Ps],
    lists:map(fun(CEs) ->
                lists:foldl(fun(CE, Acc) ->
                                CE0 = [scalece(Cedge, S, T) || Cedge <- CE],
                                case CE0 of
                                    [] -> Acc;
                                    _ -> [CE0|Acc]
                                end
                            end,[],CEs)
            end, Ps0).

getcedges(#path{ops=[#pathop{opkind=pmoveto,x1=X,y1=Y}|Ops]}) ->
    getcedges(Ops,{X,Y},{X,Y},[]);
getcedges(_) -> [].

getcedges([],{X,Y},{X,Y},Acc) -> Acc;
getcedges([],Prev,{X,Y},Acc) -> % prev != first, so close with line
    lists:reverse([#cedge{vs=Prev,ve={X,Y}}|Acc]);
getcedges([#pathop{opkind=plineto,x1=X,y1=Y}|Ops],Prev,First,Acc) ->
    getcedges(Ops,{X,Y},First,[#cedge{vs=Prev,ve={X,Y}}|Acc]);
getcedges([#pathop{opkind=pcurveto,x1=X1,y1=Y1,x2=X2,y2=Y2,x3=X,y3=Y}|Ops],Prev,First,Acc) ->
    getcedges(Ops,{X,Y},First,[#cedge{vs=Prev,cp1={X1,Y1},cp2={X2,Y2},ve={X,Y}}|Acc]);
getcedges([_|_],_,_,_) ->
    [].    % funny path (probably moveto in middle), so return nothing

scalece(#cedge{vs={Xs,Ys},cp1=nil,cp2=nil,ve={Xe,Ye}},{XS,YS},{XT,YT}) ->
    #cedge{vs={(Xs+XT)*XS,(Ys+YT)*YS},cp1=nil,cp2=nil,ve={(Xe+XT)*XS,(Ye+YT)*YS}};
scalece(#cedge{vs={Xs,Ys},cp1={X1,Y1},cp2={X2,Y2},ve={Xe,Ye}},{XS,YS},{XT,YT}) ->
    #cedge{vs={(Xs+XT)*XS,(Ys+YT)*YS},cp1={(X1+XT)*XS,(Y1+YT)*YS},cp2={(X2+XT)*XS,(Y2+YT)*YS},ve={(Xe+XT)*XS,(Ye+YT)*YS}}.

%%%
%%%

%% Check if a path is a rectangle, used to filter out rectangle clips
is_path_rectangle([#path{ops=[#pathop{opkind=pmoveto,x1=X1A,y1=Y1A},
                             #pathop{opkind=plineto,x1=X1A,y1=Y1B},
                             #pathop{opkind=plineto,x1=X1B,y1=Y1B},
                             #pathop{opkind=plineto,x1=X1B,y1=Y1A}],close=true}]) ->
    true;
is_path_rectangle(_) ->
    false.

merge_duplicates(L, CL) ->
    merge_duplicates(L, CL, []).
merge_duplicates([], _, OL) ->
    lists:unzip(lists:reverse(OL));
merge_duplicates([O1,O2|R1],[C1,C2|R2], OL) when O1 =:= O2 ->
    C3 = merge_duplicates_coltex(C1, C2),
    merge_duplicates(R1, R2, [{O1, C3}|OL]);
merge_duplicates([O1|R1],[C1|R2], OL) ->
    merge_duplicates(R1, R2, [{O1,C1}|OL]).

merge_duplicates_coltex(#coltex{fcol=FCol1,scol=SCol1,tex=Tex1}=C1,#coltex{fcol=FCol2,scol=SCol2,tex=Tex2}=_) ->
    C1#coltex{
        fcol=whichever_not_none(FCol1, FCol2),
        scol=whichever_not_none(SCol1, SCol2),
        tex=whichever_not_none(Tex1, Tex2)
    }.
whichever_not_none(none, A) -> A;
whichever_not_none(A, _) -> A.

%%%
%%%

-type maybe_image_data() :: {jpeg, binary()} | unused.

-spec get_bitmap(maybe_image_data()) -> {ok, #e3d_image{}} | {error, any()}.

get_bitmap({jpeg, BinData}) ->
    binary_to_tempfile(".jpg", BinData, fun read_jpeg/1).

read_jpeg(FileName) ->
    BlockWxMsgs = wxLogNull:new(),
    Ret = read_jpeg_1(FileName),
    wxLogNull:destroy(BlockWxMsgs),
    Ret.
read_jpeg_1(FileName) ->
    Image = wxImage:new(),
    case wxImage:loadFile(Image, FileName) of
        true ->
            E3d = wings_image:wxImage_to_e3d(Image),
            wxImage:destroy(Image),
            {ok, e3d_image:fix_outtype(FileName, E3d, [])};
        false ->
            {error, none}
    end.
uniq_name(TmpDir, Ext) ->
    FileIdNum = abs(erlang:unique_integer()),
    FileId = "w3d_ps_" ++ integer_to_list(FileIdNum) ++ Ext,
    TempFile = filename:join(TmpDir, FileId),
    case file:read_file_info(TempFile) of
        {ok, _} ->
            uniq_name(TmpDir, Ext);
        _ ->
            TempFile
    end.
binary_to_tempfile(Ext, Bin, F) ->
    TmpDir = wings_u:basedir(user_cache),
    TempFile = uniq_name(TmpDir, Ext),
    case file:write_file(TempFile, Bin) of
        ok ->
            Ret = F(TempFile),
            file:delete(TempFile),
            Ret;
        _ ->
            {error, none}
    end.




%%%
%%% Read embedded images from PS/EPS
%%%

-type emb_image_matrix() :: {float(), float(), float(), float(), float(), float()}.

-type emb_image_declist() :: [integer()].

-type emb_dec_header_item() :: 
    {atom(), integer() | float() | string() | boolean() | emb_image_matrix() | emb_image_declist()}.

-record(emb_image, {
    encoding :: hex | asc85,
    filetype :: dctdecode | lzwdecode | raw,
    decheader :: [emb_dec_header_item()],
    psenc :: binary()
}).

%% Extract the embedded images from the rest of the postscript, and
%% return them as a list, as well as return the postscript with the images
%% replaced with an importer internal command.
%%
-spec get_emb_images(binary()) -> {[maybe_image_data()], binary()}.
get_emb_images(Cont) ->
    {ImgBins, EPS} = partition_emb_imgs(Cont),
    {[get_image(ImgB) || ImgB <- ImgBins], EPS}.
get_image(#emb_image{encoding=Enc,filetype=FileType,decheader=Hdr,psenc=PSEncBin}) ->
    %% Seek ahead a bit after the image command to get the
    %% start of the encoding.
    PSEncBin_1 = seek_img_start(PSEncBin),
    FileCont = img_to_bin(Enc, PSEncBin_1),
    get_image_1(FileType, Hdr, FileCont).
get_image_1(dctdecode, _Hdr, Cont) ->
    case unscramble_jpg(Cont) of
        unsure ->
            unused;
        Cont1 when is_binary(Cont1) ->
            {jpeg, Cont1}
    end;
get_image_1(_, _Hdr, _Cont) ->
    unused.


%% Some software store the jpeg file verbatim but seem to scramble the header
%% part of it.
%%
-spec unscramble_jpg(binary()) -> binary() | unsure.
unscramble_jpg(<<16#FF,16#D8,16#FF,_/binary>>=Cont) ->
    %% Probably not scrambled.
    Cont;
unscramble_jpg(Content) when byte_size(Content) > 300 ->
    case unscramble_jpg_find(Content, 1) of
        {found, FPartAt} ->
            FirstPart = binary:part(Content, 0, FPartAt),
            Rest = binary:part(Content, FPartAt, byte_size(Content)-FPartAt),
            FirstPart_1 = unscramble_jpg_reverse(FirstPart, []),
            <<FirstPart_1/binary, Rest/binary>>;
        false ->
            unsure
    end.
unscramble_jpg_find(Content, I) when I =< 75 ->
    case binary:part(Content, I * 4, 3) =:= <<16#FF,16#D8,16#FF>> of
        true ->
            {found, (I * 4) + 4};
        false ->
            unscramble_jpg_find(Content, I+1)
    end;
unscramble_jpg_find(_, I) when I > 75 ->
    false.
    
unscramble_jpg_reverse(<<B:4/binary-unit:8,Cont/binary>>, OL) ->
    unscramble_jpg_reverse(Cont, [B|OL]);
unscramble_jpg_reverse(<<>>, OL) ->
    iolist_to_binary(OL).

    
%% Look for embedded images and partition them out of the EPS source.
-spec partition_emb_imgs(binary()) -> {[#emb_image{}], binary()}.
partition_emb_imgs(Cont) ->
    partition_emb_imgs(Cont, [], 0, byte_size(Cont)).
partition_emb_imgs(Cont, OL, A, ALn) ->
    case binary:match(Cont, <<"<<">>, [{scope, {A, ALn-A}}]) of
        nomatch ->
            %% There are no image properties so there are probably no embedded
            %% images
            {OL, Cont};
        {S1, _} ->
            %% We found an image property, we'll need to find out the encoding
            %% to find out the closing delimiter. The closing delimiter depends
            %% on the encoding.
            {_, Enc, FileType, Hdr} = find_file_type(Cont, A, S1),
            case partition_emb_imgs_enc(Enc, Cont, S1, ALn, length(OL)) of
                nomatch ->
                    {OL, Cont};
                {Enc_1, BinAtt, Cont_3} ->
                    Img = #emb_image{encoding=Enc_1,filetype=FileType,decheader=Hdr,psenc=BinAtt},
                    partition_emb_imgs(Cont_3, [Img|OL], A, byte_size(Cont_3))
            end
    end.

%% Try to find the encoding for the embedded image, it is needed
%% as the delimiter is different for ASCIIHexDecode and ASCII85Decode.
%% Also get the file type (jpeg, lzw encoded image, etc.), and 
%% return the other image information that will be needed to decode it.
%%
find_file_type(Cont, A, S1) ->
    ALn = byte_size(Cont),
    case binary:match(Cont, <<">>">>, [{scope, {S1, ALn-S1}}]) of
        nomatch ->
            %% Did not find a close to image properties.
            {A, unknown};
        {S2, _} ->
            %% Look first inside the << >> fields and try anywhere
            %% before that if nothing is found
            case find_file_enc_1(Cont, S1, S2) of
                unknown ->
                    Enc = find_file_enc_1(Cont, A, S1);
                FoundEnc ->
                    Enc = FoundEnc
            end,
            %% Embedded image header
            Hdr = parse_image_header(binary:part(Cont, S1+2, S2-S1-2)),
            %% File type (if dctdecode it could be a usable jpeg).
            case find_file_type_1(Cont, S1, S2) of
                raw ->
                    Type = find_file_type_1(Cont, A, S1);
                FoundType ->
                    Type = FoundType
            end,
            {S2, Enc, Type, Hdr}
    end.


find_file_enc_1(Cont, A, S2) ->
    case binary:match(Cont, <<"ASCII85Decode">>, [{scope, {A, S2-A}}]) of
        nomatch ->
            find_file_enc_2(Cont, A, S2);
        {_, _} ->
            asc85
    end.
find_file_enc_2(Cont, A, S2) ->
    case binary:match(Cont, <<"ASCIIHexDecode">>, [{scope, {A, S2-A}}]) of
        nomatch ->
            unknown;
        {_, _} ->
            hex
    end.


find_file_type_1(Cont, A, S2) ->
    case binary:match(Cont, <<"DCTDecode">>, [{scope, {A, S2-A}}]) of
        nomatch ->
            find_file_type_2(Cont, A, S2);
        {_, _} ->
            dctdecode
    end.
find_file_type_2(Cont, A, S2) ->
    case binary:match(Cont, <<"LZWDecode">>, [{scope, {A, S2-A}}]) of
        nomatch ->
            raw;
        {_, _} ->
            lzwdecode
    end.


partition_emb_imgs_enc(asc85, Cont, S1, ALn, NextImg) ->
    partition_emb_imgs_85(Cont, S1, ALn, NextImg);
partition_emb_imgs_enc(hex, Cont, S1, ALn, NextImg) ->
    partition_emb_imgs_hex(Cont, S1, ALn, NextImg);
partition_emb_imgs_enc(unknown, Cont, S1, ALn, NextImg) ->
    %% If we're not sure try ascii85
    partition_emb_imgs_85(Cont, S1, ALn, NextImg).

%% Split out ASCII85 image data and put a pseudo command in its place
%%
partition_emb_imgs_85(Cont, S1, ALn, NextImg) ->
    case binary:match(Cont, <<"~>">>, [{scope, {S1, ALn-S1}}]) of
        nomatch ->
            nomatch;
        {S2_0, _} ->
            S2 = S2_0 + 2,
            Cont_1 = binary:part(Cont, 0, S1),
            Cont_2 = binary:part(Cont, S2, ALn-S2),
            BinAtt = binary:part(Cont, S1+2, S2-S1-2),
            IR_T = io_lib:format("\n ~w ~w ~s \n", [0, NextImg, ?W3DEMBEDIMG]),
            IR = iolist_to_binary(IR_T),
            Cont_3 = <<Cont_1/binary, IR/binary, Cont_2/binary>>,
            {asc85, BinAtt, Cont_3}
    end.

%% Split out hex image data and put a pseudo command in its place
%%
partition_emb_imgs_hex(Cont, S1, ALn, NextImg) ->
    %% First skip over image properties closing tag.
    {S1_B_0, _} = binary:match(Cont, <<">>">>, [{scope, {S1, ALn-S1}}]),
    S1_B = S1_B_0 + 2,
    case binary:match(Cont, <<">">>, [{scope, {S1_B, ALn-S1_B}}]) of
        nomatch ->
            nomatch;
        {S2_0, _} ->
            S2 = S2_0 + 1,
            Cont_1 = binary:part(Cont, 0, S1),
            Cont_2 = binary:part(Cont, S2, ALn-S2),
            BinAtt = binary:part(Cont, S1+2, S2-S1-2),
            IR_T = io_lib:format("\n ~w ~w ~s \n", [0, NextImg, ?W3DEMBEDIMG]),
            IR = iolist_to_binary(IR_T),
            Cont_3 = <<Cont_1/binary, IR/binary, Cont_2/binary>>,
            {hex, BinAtt, Cont_3}
    end.

%% Seek to the beginning of the encoded bytes, which begins after a newline
%% after a word (sometimes it is image, but can be a macro word), which we need
%% to find first after the close of the image properties block.
-spec seek_img_start(binary()) -> binary().
seek_img_start(Cont) ->
    ALn = byte_size(Cont),
    {S1, _} = binary:match(Cont, <<">>">>), %% Close of image properties
    {S2_0, S2_L} = binary:match(Cont, [<<"\r\n">>,<<"\n">>,<<"\r">>], [{scope, {S1, ALn-S1}}]),
    S2 = S2_0 + S2_L,
    seek_img_start_1(Cont, S2, ALn).
seek_img_start_1(Cont, S2, ALn) ->
    S2AB = seek_img_start_mv_after_blank(Cont, S2),
    {S3_0, S3_L} = binary:match(Cont, [<<"\r\n">>,<<"\n">>,<<"\r">>], [{scope, {S2AB, ALn-S2AB}}]),
    S3 = S3_0 + S3_L,
    if S2AB =:= S3_0 ->
            seek_img_start_1(Cont, S3, ALn);
        true ->
            binary:part(Cont, S3, ALn-S3)
    end.
seek_img_start_mv_after_blank(Cont, S2) ->
    case binary:at(Cont, S2) of
        C when C =:= 32; C =:= 9 ->
            seek_img_start_mv_after_blank(Cont, S2+1);
        _ ->
            S2
    end.


    
img_to_bin(hex, Cont) ->
    %% Remove delimiter
    Cont1 = binary:part(Cont, 0, byte_size(Cont)-1),
    dchex(Cont1);
img_to_bin(asc85, Cont) ->
    %% Remove delimiter
    Cont1 = binary:part(Cont, 0, byte_size(Cont)-2),
    dc85(Cont1).

-spec dc85(binary()) -> binary().
dc85(Cont) ->
    A85Chars = dc85_1(Cont, []),
    dc85_2(A85Chars, []).
dc85_1(<<C,Cont/binary>>, OL) when C =:= 32; C =:= 9; C =:= 10; C =:= 13 ->
    dc85_1(Cont, OL);
dc85_1(<<C,Cont/binary>>, OL) ->
    dc85_1(Cont, [C|OL]);
dc85_1(<<>>, OL) ->
    lists:reverse(OL).
dc85_2([$z|Cont], OL) ->
    dc85_2(Cont, [<<0,0,0,0>>,OL]);
dc85_2([C1,C2,C3,C4,C5|Cont], OL) ->
    C1_B = C1 - 33,
    C2_B = C2 - 33,
    C3_B = C3 - 33,
    C4_B = C4 - 33,
    C5_B = C5 - 33,
    Val =
        C1_B*85*85*85*85 +
        C2_B*85*85*85 +
        C3_B*85*85 +
        C4_B*85 +
        C5_B,
    Bytes = <<Val:32/big-unsigned-integer>>,
    dc85_2(Cont, [Bytes|OL]);
dc85_2([C1,C2,C3,C4], OL) ->
    dc85_2([C1,C2,C3,C4,0], [0|OL]);
dc85_2([C1,C2,C3], OL) ->
    dc85_2([C1,C2,C3,0,0], [0|OL]);
dc85_2([C1,C2], OL) ->
    dc85_2([C1,C2,0,0,0], [0|OL]);
dc85_2([C1], OL) ->
    dc85_2([C1,0,0,0,0], [0|OL]);
dc85_2([], OL) ->
    iolist_to_binary(lists:reverse(OL)).

-spec dchex(binary()) -> binary().

-define(HEXDIGIT(H1), (
       (H1 >= $A andalso H1 =< $F) orelse 
       (H1 >= $a andalso H1 =< $f) orelse
       (H1 >= $0 andalso H1 =< $9))).

dchex(Cont) ->
    dchex(Cont, []).
dchex(<<C,Cont/binary>>, OL) when C =:= 32; C =:= 9; C =:= 10; C =:= 13 ->
    dchex(Cont, OL);
dchex(<<H1,H2,Cont/binary>>, OL)
  when ?HEXDIGIT(H1), ?HEXDIGIT(H2) ->
      N = (dchex_1(H1) bsl 4) bor dchex_1(H2),
    dchex(Cont, [N|OL]);
dchex(<<>>, OL) ->
    iolist_to_binary(lists:reverse(OL)).
    
dchex_1(A) when A >= $A, A =< $F ->
    A - $A + 10;
dchex_1(A) when A >= $a, A =< $f ->
    A - $a + 10;
dchex_1(A) when A >= $0, A =< $9 ->
    A - $0.

-spec parse_image_header(binary()) -> [emb_dec_header_item()].
parse_image_header(Cont) ->
    Cont_1 = tokenize(binary_to_list(Cont), []),
    parse_image_header(Cont_1, []).
parse_image_header([{tlitname,"ImageType"},{tnum,A1}|R],OL) ->
    parse_image_header(R, [{imagetype, round(A1)}|OL]);
parse_image_header([{tlitname,"Width"},{tnum,A1}|R],OL) ->
    parse_image_header(R, [{width, round(A1)}|OL]);
parse_image_header([{tlitname,"Height"},{tnum,A1}|R],OL) ->
    parse_image_header(R, [{height, round(A1)}|OL]);
parse_image_header([{tlitname,"BitsPerComponent"},{tnum,A1}|R],OL) ->
    parse_image_header(R, [{bitspercomponent, round(A1)}|OL]);
parse_image_header([{tlitname,"Interpolate"},{tname,A0}|R],OL) ->
    case A0 of
        "true" -> A1 = true;
        _ ->      A1 = false
    end,
    parse_image_header(R, [{interpolate, A1}|OL]);
parse_image_header([{tlitname,"Decode"},{tname,"["},{tnum,A1},{tnum,A2},
                    {tnum,A3},{tnum,A4},{tnum,A5},{tnum,A6},{tname,"]"}|R],OL) ->
    parse_image_header(R, [{decode, [round(A1),round(A2),round(A3),
                                     round(A4),round(A5),round(A6)]}|OL]);
parse_image_header([{tlitname,"ImageMatrix"},{tname,"["},{tnum,A1},{tnum,A2},
                    {tnum,A3},{tnum,A4},{tnum,A5},{tnum,A6},{tname,"]"}|R],OL) ->
    parse_image_header(R, [{imagematrix, {float(A1),float(A2),float(A3),
                                          float(A4),float(A5),float(A6)}}|OL]);
parse_image_header([_|R],OL) ->
    parse_image_header(R, OL);
parse_image_header([], OL) ->
    lists:reverse(OL).


